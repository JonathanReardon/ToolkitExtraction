---
title: 'Master data extraction.Rmd'
author: "Jonathan Reardon"
output:
  html_document:
    keep_md: true
    #df_print: paged
  #pdf_document:
    #keep_md: true
editor_options:
  chunk_output_type: inline
---
**Import R libraries, save figures to "Master_figs/"**
```{r setup, message=FALSE}
knitr::opts_chunk$set(echo = T,
                      fig.path = "Master_figs/")
library(reticulate)
library(ggplot2)
library(dplyr)
library(reshape2)
library(purrr)
library(gridExtra)
library(kableExtra)
library(forestplot)
library(metafor)
use_python("/usr/local/bin/python3")
rm(list = ls())
```
**Import Python packages and (json) dataset**
```{python}
# import necessary libraries
import json
from collections import Counter
from pprint import pprint
import numpy as np
from matplotlib import pyplot as plt
import pandas as pd
plt.style.use('ggplot')

# import dataset (uncomment to select dataset of choice)
with open('/home/jon/json/ToolkitExtraction/data/batch2.json') as f:
#with open('/home/jon/json/ToolkitExtraction/data/Batch1.json') as f:
    data=json.load(f)
```
## CodeSets extraction

These functions extract attribute names and ID's (e.g. strand, educational setting) and return Python dictionaries containing attribute ID's as 'keys' and attribute names as 'values'. The 'Codesets' section at the top of the file does not contain any data, only variable information.

**Example dictionaries**  
strands&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= {5023544: 'Arts participation', 5023545: 'Aspiration interventions', .. }  
edu_setting&nbsp;&nbsp;&nbsp;= {5215410: 'Nursery school/pre-school', 5215411: 'Primary/elementary school', 5215412, .. }
```{python}
def get_strand_info():
    '''Return a dict of Strand Attribute Names & Attribute ID's'''
    strands={}
    for counter, element in enumerate(data["CodeSets"][0]["Attributes"]["AttributesList"]):
        attribute_name=(data["CodeSets"][0]["Attributes"]["AttributesList"][counter]["AttributeName"])
        attribute_id=(data["CodeSets"][0]["Attributes"]["AttributesList"][counter]["AttributeId"])
        strands.update( {attribute_id:attribute_name} )
    return strands
strands = get_strand_info()

def get_edu_info():
    '''Return a dict of Educational Setting Attribute Names & Attribute ID's'''
    edu_setting={}
    for counter, value in enumerate(data["CodeSets"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"]):
        setting_code=data["CodeSets"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"][counter]["AttributeId"]
        setting_name=data["CodeSets"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"][counter]["AttributeName"]
        edu_setting.update( {setting_code:setting_name} )
    return edu_setting
edu = get_edu_info()

def get_country_codes():
  '''Return a dict of Country Attribute Names & Attribute ID's'''
  country_codes={}
  for counter, value in enumerate(data["CodeSets"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"][0]["Attributes"]["AttributesList"]):
      country_code=data["CodeSets"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"][0]["Attributes"]["AttributesList"][counter]["AttributeId"]
      country_name=data["CodeSets"][2]["Attributes"]["AttributesList"][2]["Attributes"]["AttributesList"][0]["Attributes"]["AttributesList"][counter]["AttributeName"]
      country_codes.update( {country_code:country_name} )
  return country_codes
countries = get_country_codes()

def get_publication_type():
    '''Return a dict of Publication Type Attribute Names & Attribute ID's'''
    publication_type={}
    for counter, element in enumerate(data["CodeSets"][2]["Attributes"]["AttributesList"][0]["Attributes"]["AttributesList"][0]):
        attribute_name=(data["CodeSets"][2]["Attributes"]["AttributesList"][0]["Attributes"]["AttributesList"][counter]["AttributeName"])
        attribute_id=(data["CodeSets"][2]["Attributes"]["AttributesList"][0]["Attributes"]["AttributesList"][counter]["AttributeId"])
        publication_type.update( { attribute_id:attribute_name })
    return publication_type
pub_type = get_publication_type()
```
## Main data extraction
```{python}
def get_all():
  finds=[]
  find=0
  strandfind=0
  countryfind=0
  exclude=np.nan
  
  extracted=0
  null=0
  
  studies=0
  # iterate over each section within each study of 'references'
  for section in range(len(data["References"])):
      find=0
      strandfind=0
      
      if "Codes" in data["References"][section]:
          extracted+=1
          for study in range(len(data["References"][section]["Codes"])):
    
              # get publication type data
              for key, value in pub_type.items():
                  if key == data["References"][section]["Codes"][study]["AttributeId"]:
                      pubfind=value
                      publabel=key
                  elif find==0:
                      pubfind=exclude
                      publabel=exclude
                  
              # get country of study data
              for key, value in countries.items():
                  if key == data["References"][section]["Codes"][study]["AttributeId"]:
                      countryfind=value
                      countrylabel=key
                  elif find==0:
                      countryfind=exclude
                      countrylabel=exclude
          
              # get educational setting data (primary/elementary etc.)
              for key,value in edu.items():
                  if key == data["References"][section]["Codes"][study]["AttributeId"]:
                      find=value
                      label=key
                  elif find==0:
                      find=exclude
                      label=exclude
                  
              # get strand data (feedback, peer tutoring etc.)
              for key,value in strands.items():
                  if key == data["References"][section]["Codes"][study]["AttributeId"]:
                      strandfind=value
                      strandlabel=key
                  elif strandfind==0:
                      strandfind=exclude
                      strandlabel=exclude
                  
              # get outcome data if an "Outcomes" section exists
              if "Outcomes" in data["References"][section]:
                  outcometext=data["References"][section]["Outcomes"][0]["OutcomeText"]
                  interventiontext=data["References"][section]["Outcomes"][0]["InterventionText"]
                  SMD=(data["References"][section]["Outcomes"][0]["SMD"])
                  SESMD=(data["References"][section]["Outcomes"][0]["SESMD"])
                  CIupperSMD=(data["References"][section]["Outcomes"][0]["CIUpperSMD"])
                  CIlowerSMD=(data["References"][section]["Outcomes"][0]["CILowerSMD"])
              else:
                  outcometext=exclude
                  interventiontext=exclude
                  SMD=exclude
                  SESMD=exclude
                  CIupperSMD=exclude
                  CIlowerSMD=exclude
              
              # get year data 
              if "Year" in data["References"][section]:
                  year=int(data["References"][section]["Year"])
              else:
                  year=exclude
              
              # get author data
              if "ShortTitle" in data["References"][section]:
                  author=data["References"][section]["ShortTitle"]
              else:
                  author=exclude
              
          # append all extracted data to our 'finds' list
          finds.append([author, find, strandfind, interventiontext, 
                        outcometext, year, countryfind, pubfind, SMD, SESMD, CIupperSMD, CIlowerSMD])
                        
      else:
          null+=1
      
      # convert data list ('finds') to Pandas dataframe
      df = pd.DataFrame(finds, columns=['Author', 'EducationalSetting', 'Strand', 
                                       'Intervention', 'Outcome', 'Year', 'Country', 'PublicationType', 'SMD', 
                                       'SESMD', 'CIupper', 'CIlower'])
                                    
      #df.fillna(0)
                                    
      # round effect sizes and confidence interbals to four decimal points
      df.loc[:, "SMD"] = df["SMD"].astype(float).round(4)
      df.loc[:, "SESMD"] = df["SESMD"].astype(float, errors='ignore').round(4)
      df.loc[:, "CIupper"] = df["CIupper"].astype(float).round(4)
      df.loc[:, "CIlower"] = df["CIlower"].astype(float).round(4)
         
  print("Number of studies extracted (they have a 'Codes' section): {}".format(extracted),
        "Number of of missing studies (no 'Codes' section found):   {}".format(null),
        sep='\n')

  return df
  
master_df = get_all()
```
**Function to check "Year" range, group by decade, and insert into new 'Decade' column. Reorder columns and subset all Primary (outcome) studies**
```{python}
# add decade column
def decade_row(row):
  if row["Year"] >= 1960 and row["Year"] <= 1969:
    decade="1960-1969"
  elif row["Year"] >= 1970 and row["Year"] <= 1979:
    decade="1970-1979"
  elif row["Year"] >= 1980 and row["Year"] <= 1989:
    decade="1980-1989"
  elif row["Year"] >= 1990 and row["Year"] <= 1999:
    decade="1990-1999"
  elif row["Year"] >= 2000 and row["Year"] <= 2009:
    decade="2000-2010"
  elif row["Year"] >= 2010 and row["Year"] <= 2019:
    decade="2010-2019"
  elif row["Year"] >= 2019 and row["Year"] <= 2029:
    decade="2020-2029"
  return decade
  
# Use "Year" data to get 'decade' information and add to new column
master_df["Decade"] = master_df.apply(decade_row, axis=1)

# reorder columns
master_df = master_df[["Author", "Year", "Decade", "Country", "Outcome", "Strand", "PublicationType", 
                       "EducationalSetting", "Intervention", "SMD", "SESMD", "CIupper", "CIlower"]]

# subset all Primary Outcomes studies
primary = master_df[master_df["Outcome"] == "Primary outcome"]
```
**Data cleaning: replace all non-useful values with NA & convert columns to factors. Display Primary outcome dataset (25 rows here)**
```{r, message=FALSE, warning=FALSE, fig.width=10,fig.height=7}
# Pass all Primary outcome studies to R dataframe (from Python)
primary_outcome <- data.frame(py$primary)

# Clean data (insert NA for missing values and remove 'no info' cells)
primary_outcome$Intervention <- as.character(primary_outcome$Intervention)
primary_outcome$Intervention[primary_outcome$Intervention=="NaN"] <- NA
primary_outcome$Intervention <- as.factor(primary_outcome$Intervention)

primary_outcome$EducationalSetting <- as.character(primary_outcome$EducationalSetting)
primary_outcome$EducationalSetting[primary_outcome$EducationalSetting=="NaN"] <- NA
primary_outcome$EducationalSetting[primary_outcome$EducationalSetting=="No information provided"] <- NA
primary_outcome$EducationalSetting[primary_outcome$EducationalSetting=="Other educational setting (please specify)"] <- NA
primary_outcome$EducationalSetting <- as.factor(primary_outcome$EducationalSetting)

primary_outcome$Strand <- as.character(primary_outcome$Strand)
primary_outcome$Strand[primary_outcome$Strand=="NaN"] <- NA
primary_outcome$Strand <- as.factor(primary_outcome$Strand)

primary_outcome$Country <- as.character(primary_outcome$Country)
primary_outcome$Country[primary_outcome$Country=="NaN"] <- NA
primary_outcome$Country <- as.factor(primary_outcome$Country)

primary_outcome$Outcome <- as.character(primary_outcome$Outcome)
primary_outcome$Outcome[primary_outcome$Outcome=="NaN"] <- NA
primary_outcome$Outcome <- as.factor(primary_outcome$Outcome)

primary_outcome$PublicationType <- as.character(primary_outcome$PublicationType)
primary_outcome$PublicationType[primary_outcome$PublicationType=="NaN"] <- NA
primary_outcome$PublicationType[primary_outcome$PublicationType=="Other (Please specify)"] <- NA
primary_outcome$PublicationType <- as.factor(primary_outcome$PublicationType)

# replace "UK (Select all that apply)" with "UK" for plotting without UK breakdown
primary_outcome$Country <- as.character(primary_outcome$Country)
primary_outcome$Country[primary_outcome$Country=="UK (Select all that apply)"] <- "UK"
primary_outcome$Country <- as.factor(primary_outcome$Country)

# uncomment to view all primary outcome studies (rstudio)
#View(primary_outcome)

rownames(primary_outcome) <- NULL
# display data with kable and inspect subsetted columns (highlighted)
primary_outcome[1:25,1:12] %>%
  mutate(Outcome = cell_spec(Outcome, color = "white", bold = T, background = spec_color(.9, end = .9))) %>%
  kable(escape = F, align = "l") %>%
  column_spec(5, width="30mm") %>%
  kable_styling(c("hover", "condensed", "responsive", "bordered"), full_width = T, font_size = 9)
```

**Subset 'Primary/elementary school' & 'Secondary/High school' data (Primary outcomes only), then from each of those get "Feedback" strand data only**
```{r, message=FALSE, warning=FALSE, fig.width=10,fig.height=7}
schools <- primary_outcome %>% 
  select(Author, Strand, EducationalSetting, SMD, CIupper, CIlower) %>%
  filter(EducationalSetting %in% c("Primary/elementary school", "Secondary/High school")) %>%
  filter(Strand=="Feedback")

rownames(schools) <- NULL
# display data with kable and inspect subsetted columns (highlighted)
schools[1:25,1:6] %>%
  mutate(
    Strand = cell_spec(Strand, color = "white", bold = T, background = spec_color(.9, end = .9)),
    EducationalSetting = cell_spec(EducationalSetting, color = "white", bold = T, background = spec_color(.9, end = .9))) %>%
  kable(escape = F, align = "l") %>%
  kable_styling(c("hover", "condensed", "responsive", "bordered"), full_width = F, font_size = 12)
```
**Make Primary/Elementary and High school forest plots and display them**
```{r, message=FALSE, warning=FALSE, fig.width=8,fig.height=7}
Primary_plot <- ggplot(data=na.omit(subset(schools, select=c(EducationalSetting=="Primary/elementary school", Author, SMD, CIlower, CIupper))),
                    aes(y=Author, x=SMD, xmin=CIlower, xmax=CIupper))+
                    geom_point(color='black', shape=15) +
                    geom_errorbarh(height=.7, linetype=1) +
                    scale_x_continuous(limits=c(-4,4), name='Standardized Mean Difference (95% CI)') +
                    ylab('Reference') +
                    geom_vline(xintercept=0, color='black', linetype='dashed') +
                    theme_classic() +
                    ggtitle("Primary School, Feedback Strand, Primary outcome")

High_plot <- ggplot(data=na.omit(subset(schools, select=c(EducationalSetting=="Secondary/High school", Author, SMD, CIlower, CIupper))),
                    aes(y=Author, x=SMD, xmin=CIlower, xmax=CIupper))+
                    geom_point(color='black', shape=15) +
                    geom_errorbarh(height=.7, linetype=1) +
                    scale_x_continuous(limits=c(-4,4), name='Standardized Mean Difference (95% CI)') +
                    ylab('Reference') +
                    geom_vline(xintercept=0, color='black', linetype='dashed') +
                    theme_classic() +
                    ggtitle("High School, Feeback Strand, Primary Outcome")

Primary_plot
```

**Subset 'Primary/elementary school' & 'Secondary/High school' data (Primary outcomes only), then from each of those get "Feedback" strand data only**
```{r, message=FALSE, warning=FALSE, fig.width=10,fig.height=7}
countries <- primary_outcome %>% 
  select(Author, Strand, Country, SMD, CIupper, CIlower) %>%
  filter(Country %in% c("USA", "UK")) %>%
  filter(Strand=="Feedback")

rownames(countries) <- NULL
# display data with kable and inspect subsetted columns (highlighted)
countries[1:25,1:6] %>%
  mutate(
    Strand  = cell_spec(Strand, color = "white", bold = T, background = spec_color(.9, end = .9)),
    Country = cell_spec(Country, color = "white", bold = T, background = spec_color(.9, end = .9))) %>%
  kable(escape = F, align = "l") %>%
  kable_styling(c("hover", "condensed", "responsive", "bordered"), full_width = F, font_size = 12)
```
**Make UK and USA (Primary Outcome) study forest plots and display them**
```{r, message=FALSE, warning=FALSE, fig.width=8,fig.height=10}
Primary_UK_plot <- ggplot(data=na.omit(subset(countries, select=c(Country=="UK", Author, SMD, CIlower, CIupper))),
                    aes(y=Author, x=SMD, xmin=CIlower, xmax=CIupper))+
                    geom_point(color='black', shape=15) +
                    geom_errorbarh(height=.7, linetype=1) +
                    scale_x_continuous(limits=c(-4,4), name='Standardized Mean Difference (95% CI)') +
                    ylab('Reference') +
                    geom_vline(xintercept=0, color='black', linetype='dashed') +
                    theme_classic() +
                    ggtitle("UK studies, Primary outcome") +
                    theme(axis.text.x = element_text(colour = "black", size=11),
                          axis.text.y = element_text(colour = "black", size=11)) +
                    theme(axis.title.x = element_text(colour = "black", size=16),
                          axis.title.y = element_text(colour = "black", size=16))

Primary_USA_plot <- ggplot(data=na.omit(subset(countries, select=c(Country=="UK", Author, SMD, CIlower, CIupper))),
                    aes(y=Author, x=SMD, xmin=CIlower, xmax=CIupper))+
                    geom_point(color='black', shape=15) +
                    geom_errorbarh(height=.5, linetype=1) +
                    scale_x_continuous(limits=c(-4,4), name='Standardized Mean Difference (95% CI)') +
                    ylab('Authors') +
                    geom_vline(xintercept=0, color='black', linetype='dashed') +
                    theme_classic() +
                    ggtitle("USA studies, Primary Outcome") +
                    theme(axis.text.x = element_text(colour = "black", size=11),
                          axis.text.y = element_text(colour = "black", size=11)) +
                    theme(axis.title.x = element_text(colour = "black", size=16),
                          axis.title.y = element_text(colour = "black", size=16))

Primary_USA_plot
```

**Make jittered dotplots of SMD by Decade, grouped by Strand, Intervention, Country, Educational Setting, and Publication Type**
```{r, fig.width=20,fig.height=18}
# list reusable layers to use on all plots (constants)
gglayers <- list(
  ylim(-2,3.5),
  theme(legend.justification = "top"),
  theme(axis.text.x = element_text(colour = "black", size=12),
        axis.text.y = element_text(colour = "black", size=12)),
  theme(axis.title.x = element_text(colour = "black", size=16),
        axis.title.y = element_text(colour = "black", size=16)),
  theme(legend.title = element_text(color = "black", size = 12),
        legend.text = element_text(color = "black", size = 11)),
  theme(plot.title = element_text(face="bold", colour="black", size="16"))
)

# plot of SMD by Decade grouped (color) by Strand
strand <- filter(primary_outcome, !is.na(Strand)) %>%
  ggplot(aes(y=SMD, x=Decade, fill=Strand)) +
  geom_jitter(position=position_jitter(.2), size=4, shape=21, stroke=1, na.rm=TRUE) +
  labs(fill = "Strand") +
  ggtitle("Plot of SMD by Decade, grouped by Strand") + gglayers

# plot of SMD by Decade grouped (color) by Intervention
intervention <- filter(primary_outcome, !is.na(Intervention)) %>%
  ggplot(aes(y=SMD, x=Decade, fill=Intervention)) +
  geom_jitter(position=position_jitter(.2), size=4, shape=21, stroke=1, na.rm=TRUE) +
  labs(fill = "Intervention") +
  ggtitle("Plot of SMD by Decade, grouped by Intervention") + gglayers

# plot of SMD by Decade grouped (color) by Country
country <- filter(primary_outcome, !is.na(Country)) %>%
  ggplot(aes(y=SMD, x=Decade, fill=Country)) +
  geom_jitter(position=position_jitter(.2), size=4, shape=21, stroke=1, na.rm=TRUE) +
  labs(fill = "Country") +
  ggtitle("Plot of SMD by Decade, grouped by Country") + gglayers

# plot of SMD by Decade grouped (color) by Educational Setting
edu_setting <- filter(primary_outcome, !is.na(EducationalSetting)) %>%
  ggplot(aes(y=SMD, x=Decade, fill=EducationalSetting)) +
  geom_jitter(position=position_jitter(.2), size=4, shape=21, stroke=1, na.rm=TRUE) +
  labs(fill = "Educational Setting") +
  ggtitle("Plot of SMD by Decade, grouped by Educational Setting") + gglayers

# plot of SMD by Decade grouped (color) by Publication Type
pub_type <- filter(primary_outcome, !is.na(PublicationType)) %>%
  ggplot(aes(y=SMD, x=Decade, fill=PublicationType)) +
  geom_jitter(position=position_jitter(.2), size=4, shape=21, stroke=1, na.rm=TRUE) +
  labs(fill = "Publication Type") +
  ggtitle("Plot of SMD by Decade, grouped by Publication Type") + gglayers

# display all plots on a grid
grid.arrange(strand, intervention, country, edu_setting, pub_type, ncol=2)
```
**Get all study data (Primary outcome only), convert all missing data to NA. Remove "No information" cells (from educational setting column). Plot SMD/SESMD scatter plots groups by intervention, educational setting, strand, and country**
```{r, fig.width=14,fig.height=19}
# get means for SMD and SESMD
master_df_mean_SMD    <- mean(primary_outcome$SMD, na.rm=TRUE)
master_dfk_mean_SESMD <- mean(primary_outcome$SESMD, na.rm=TRUE)

# uncomment to view data in dataviewer
#View(master_df) 

gglayers <- list(
  theme_grey(),
  geom_vline(xintercept=master_df_mean_SMD, linetype="dotted", color="black", size=1),
  theme(legend.title = element_text(color = "black", size = 10),
  legend.text = element_text(color = "black", size = 11)),
  theme(legend.position="right"),
  guides(fill=guide_legend(nrow=5, byrow=TRUE)),
  annotate(geom="text", x=master_df_mean_SMD+.15, y=-.1, label=round(master_df_mean_SMD, 2), color="black"),
  ylim(-0.2, 1.75),
  xlim(-1.5, 2.5)
)
  
# Make SMD/SESMD scatter plot, (color) grouped by Intervention
smd_intervention <- ggplot(data=subset(primary_outcome, !is.na(Intervention)), aes(SMD, SESMD, color=Intervention)) + 
    geom_point(alpha=1, na.rm=TRUE, size=1.5) +
    ggtitle("SMD by SESMD grouped by Intervention") +
    labs(fill = "Intervention") + gglayers

# Make SMD/SESMD scatter plot, (color) grouped by Educational Setting
smd_edusetting <- ggplot(data=subset(primary_outcome, !is.na(EducationalSetting)), aes(SMD, SESMD, color=EducationalSetting)) + 
    geom_point(alpha=1, na.rm=TRUE, size=1.5) +
    ggtitle("SMD by SESMD grouped by Educational Setting") +
    labs(fill = "Educational Setting") + gglayers

# Make SMD/SESMD scatter plot, (color) grouped by Strand
smd_strand <- ggplot(data=subset(primary_outcome, !is.na(Strand)), aes(SMD, SESMD, color=Strand)) + 
    geom_point(alpha=1, na.rm=TRUE, size=1.5) +
    ggtitle("SMD by SESMD grouped by Strand") +
    labs(fill = "Strand") + gglayers

# Make SMD/SESMD scatter plot, (color) grouped by Country
smd_country <- ggplot(data=subset(primary_outcome, !is.na(Country)), aes(SMD, SESMD, color=Country)) + 
    geom_point(alpha=1, na.rm=TRUE, size=1.5) +
    ggtitle("SMD by SESMD grouped by Country") +
    labs(fill = "Country") + gglayers

# use GridExtra to display all 4 plots neatly
grid.arrange(smd_intervention, smd_edusetting, smd_strand, smd_country, nrow=4)
```